"""
Date:        4/14/2025 
Class:       SignatureScanner
Description: This class is responsible for implementing the SHA256
             signature-based scanning functionality. This class inherits
             the parent Scanner class, and utilizes the database_handler.
             The goal should be for this class to eventually output a 
             Scan_Result object to the DB.
"""
from structs import File_Scan_Report
from scanners.scanner import Scanner
import utils
import os
from tqdm import tqdm
from typing import List
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging

logger = logging.getLogger(__name__)

class SignatureScanner(Scanner):
    
    def __init__(self, db_handler, max_workers=8):
        super().__init__(db_handler)
        self.max_workers = max_workers

    def scan_file(self, path):
        try:
            if os.path.isdir(path):
                raise Exception("Expected file path but got directory instead")

            logger.info(f"Scanning file path {path}")

            absolute_path = os.path.abspath(path)
            file_size = os.path.getsize(absolute_path)

            if file_size < 104_857_600:  # 100 MB
                file_hash = utils.hash_file_chunked(absolute_path)
                has_signature = self.db_handler.search_signatures_table(file_hash)
            else:
                file_hash = None
                has_signature = None

            return File_Scan_Report(
                path=absolute_path,
                size_bytes=file_size,
                sha256=file_hash if file_hash else None,  # Optionally store `file_hash` here
                is_malware=True if has_signature else False,
                scan_type="signature"
            )
        except Exception as e:
            logger.warning(f"Error scanning file {path}: {e}")
            return None

    def scan(self, path):
        file_scan_reports: List[File_Scan_Report] = []

        absolute_path = os.path.abspath(path)
        logger.info(f"Starting Scan on {absolute_path}")

        # Collect all file paths
        all_files = []
        for dirpath, _, filenames in os.walk(absolute_path):
            for filename in filenames:
                all_files.append(os.path.join(dirpath, filename))

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = {executor.submit(self.scan_file, fp): fp for fp in all_files}
            for future in tqdm(as_completed(futures), total=len(futures), desc="Signature Scan", unit="file"):
                result = future.result()
                if result:
                    file_scan_reports.append(result)

        return file_scan_reports

            