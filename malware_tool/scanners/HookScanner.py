import os
import logging
import psutil
import pefile
import hashlib
import ctypes
from ctypes import wintypes
from structs import File_Scan_Report

logger = logging.getLogger(__name__)

PROCESS_ALL_ACCESS = 0x1F0FFF
MAX_PROLOGUE_SIZE = 16  # bytes to compare

# Windows API bindings
kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
OpenProcess = kernel32.OpenProcess
ReadProcessMemory = kernel32.ReadProcessMemory
CloseHandle = kernel32.CloseHandle

OpenProcess.argtypes = [wintypes.DWORD, wintypes.BOOL, wintypes.DWORD]
OpenProcess.restype = wintypes.HANDLE
ReadProcessMemory.argtypes = [wintypes.HANDLE, wintypes.LPCVOID, wintypes.LPVOID, ctypes.c_size_t, ctypes.POINTER(ctypes.c_size_t)]
ReadProcessMemory.restype = wintypes.BOOL

class HookScanner:
    def __init__(self, db_handler):
        self.db_handler = db_handler

    def scan(self):
        """
        Scans all running processes for inline hooks by comparing in-memory and on-disk prologues.
        """
        logger.info("Starting hook scan on running processes...")
        malicious = set()  # Use a set to avoid duplicates
        results = []

        for proc in psutil.process_iter(['pid', 'exe']):
            try:
                pid = proc.info['pid']
                path = proc.info['exe']
                if not path or not os.path.exists(path):
                    continue

                if self._scan_process(pid, path):
                    malicious.add(path)  # Add to set

            except (psutil.NoSuchProcess, psutil.AccessDenied) as e:
                logger.warning(f"Cannot access process {proc}: {e}")
                continue

        for proc_path in malicious:
            try:
                size = os.path.getsize(proc_path)
                with open(proc_path, "rb") as f:
                    sha256 = hashlib.sha256(f.read()).hexdigest()

                report = File_Scan_Report(
                    path=proc_path,
                    size_bytes=size,
                    sha256=sha256,
                    is_malware=True
                )
                results.append(report)
                self.db_handler.insert_file_scan_report(report)
            except Exception as e:
                logger.error(f"Failed to generate report for {proc_path}: {e}")

        return results


    def _scan_process(self, pid, exe_path):
        """
        Compares the memory of a running process to its on-disk version to detect inline hooks.
        """
        logger.info(f"Scanning process PID={pid}, path={exe_path}")

        try:
            pe = pefile.PE(exe_path)
            entry = pe.OPTIONAL_HEADER.AddressOfEntryPoint
            image_base = pe.OPTIONAL_HEADER.ImageBase
            file_prologue = pe.get_memory_mapped_image()[entry:entry + MAX_PROLOGUE_SIZE]
        except Exception as e:
            logger.error(f"Failed to parse PE file for {exe_path}: {e}")
            return False

        # Open the process
        h_process = OpenProcess(PROCESS_ALL_ACCESS, False, pid)
        if not h_process:
            logger.warning(f"Failed to open process {pid}")
            return False

        # Read process memory at entry point
        entry_addr = image_base + entry
        buffer = (ctypes.c_char * MAX_PROLOGUE_SIZE)()
        bytes_read = ctypes.c_size_t()

        success = ReadProcessMemory(h_process, ctypes.c_void_p(entry_addr), buffer, MAX_PROLOGUE_SIZE, ctypes.byref(bytes_read))
        CloseHandle(h_process)

        if not success or bytes_read.value != MAX_PROLOGUE_SIZE:
            logger.warning(f"Failed to read memory from process {pid}")
            return False

        mem_prologue = bytes(buffer[:MAX_PROLOGUE_SIZE])

        # Compare
        if mem_prologue != file_prologue:
            logger.warning(f"Potential inline hook detected in {exe_path}")
            return True

        return False