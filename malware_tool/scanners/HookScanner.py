import os
import logging
import psutil
import pefile
import hashlib
import ctypes
from ctypes import wintypes
from tqdm import tqdm
from structs import File_Scan_Report

logger = logging.getLogger(__name__)

PROCESS_QUERY_INFORMATION = 0x0400
PROCESS_VM_READ = 0x0010
PARTIAL_ACCESS = PROCESS_QUERY_INFORMATION | PROCESS_VM_READ
MAX_PROLOGUE_SIZE = 16

# Windows API bindings
kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
OpenProcess = kernel32.OpenProcess
ReadProcessMemory = kernel32.ReadProcessMemory
CloseHandle = kernel32.CloseHandle

OpenProcess.argtypes = [wintypes.DWORD, wintypes.BOOL, wintypes.DWORD]
OpenProcess.restype = wintypes.HANDLE
ReadProcessMemory.argtypes = [wintypes.HANDLE, wintypes.LPCVOID, wintypes.LPVOID, ctypes.c_size_t, ctypes.POINTER(ctypes.c_size_t)]
ReadProcessMemory.restype = wintypes.BOOL

class HookScanner:
    def __init__(self, db_handler):
        self.db_handler = db_handler

    def scan(self):
        logger.info("Starting hook scan on running processes...")
        malicious = set()
        results = []

        processes = list(psutil.process_iter(['pid', 'exe']))
        for proc in tqdm(processes, desc="Scanning processes", unit="proc"):
            try:
                pid = proc.info['pid']
                path = proc.info['exe']
                if not path or not os.path.exists(path):
                    continue

                logger.debug(f"Attempting to scan process {pid} at {path}")
                if self._scan_process(pid, path):
                    malicious.add(path)

            except (psutil.NoSuchProcess, psutil.AccessDenied) as e:
                logger.warning(f"Cannot access process {proc}: {e}")
                continue

        for proc_path in malicious:
            try:
                size = os.path.getsize(proc_path)
                with open(proc_path, "rb") as f:
                    sha256 = hashlib.sha256(f.read()).hexdigest()

                report = File_Scan_Report(
                    path=proc_path,
                    size_bytes=size,
                    sha256=sha256,
                    is_malware=True,
                    scan_type=self.__class__.__name__
                )
                results.append(report)
                self.db_handler.insert_file_scan_report(report)
            except Exception as e:
                logger.error(f"Failed to generate report for {proc_path}: {e}")

        logger.info(f"Hook scan complete. {len(results)} suspicious file(s) found.")
        return results

    def _scan_process(self, pid, exe_path):
        logger.info(f"Scanning process PID={pid}, path={exe_path}")

        try:
            pe = pefile.PE(exe_path)
            entry = pe.OPTIONAL_HEADER.AddressOfEntryPoint
            image_base = pe.OPTIONAL_HEADER.ImageBase
            file_prologue = pe.get_memory_mapped_image()[entry:entry + MAX_PROLOGUE_SIZE]
        except Exception as e:
            logger.error(f"Failed to parse PE file for {exe_path}: {e}")
            return False

        h_process = OpenProcess(PARTIAL_ACCESS, False, pid)
        if not h_process:
            logger.warning(f"Failed to open process {pid}")
            return False

        entry_addr = image_base + entry
        buffer = (ctypes.c_char * MAX_PROLOGUE_SIZE)()
        bytes_read = ctypes.c_size_t()

        success = ReadProcessMemory(
            h_process,
            ctypes.c_void_p(entry_addr),
            buffer,
            MAX_PROLOGUE_SIZE,
            ctypes.byref(bytes_read)
        )
        CloseHandle(h_process)

        if not success or bytes_read.value != MAX_PROLOGUE_SIZE:
            logger.warning(
                f"Failed to read memory from process {pid} at 0x{entry_addr:X} "
                f"(read {bytes_read.value} bytes, expected {MAX_PROLOGUE_SIZE})"
            )
            return False

        mem_prologue = bytes(buffer[:MAX_PROLOGUE_SIZE])

        if mem_prologue != file_prologue:
            logger.warning(f"Potential inline hook detected in {exe_path}")
            return True

        logger.info(f"No hook detected in process {pid} ({exe_path})")
        return False
